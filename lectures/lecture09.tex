\section{Вычислимость}
\subsection{Введение}
В данном параграфе $\Sigma$ -- это конечный алфавит, а $\Sigma^*$ - множество строк в нем.

Пока что не будем давать точное определение понятия алгоритм, а просто выпишем его главные характеристики: 
\begin{itemize}
    \item Алгоритм получает на вход строку и либо завершается и выдает какую-то строку, либо не останавливается.
    \item Алгоритм можно записать.
    \item Алгоритм можно исполнять по шагам.
\end{itemize}
Введем еще одно обозначение: $\mathcal{N} := \{0, 1, 2, \dots \}$ -- натуральные числа с 0. Обычные натуральные числа без 0 все так же будем обозначать $\N$.

\begin{conj}
    $S \subseteq \mathcal{N}$ называется разрешимым, если существует такой алгоритм $\mathcal{A}$, что \begin{itemize}
        \item $\forall x \in S \quad \mathcal{A}(x) = 1$
        \item $\forall x \notin S \quad \mathcal{A}(x) = 0.$
    \end{itemize}
\end{conj}
Заметим, что в свойствах алгоритма мы говорили про то, что на вход ему подаются строки, а тут -- натуральные числа. Но это законно, потому что мы можем отождествить натуральные числа со строками: сначала идет пустая строка, потом все строки длины 1 (их конечное число), потом все строки длины 2 (их конечное число) и т.д.

\textbf{Примеры разрешимых множеств:} \begin{enumerate}
    \item Само $\mathcal{N}$ разрешимо (всегда выдаем 1) и $\varnothing$ разрешимо (всегда выдаем 0).
    \item Множество четных чисел (просто проверяем на четность)
    \item Множество простых чисел (можем честно проверить на простоту, время выполнения нас не волнует)
    \item Любое конечное множество (просто проверяем, что вход алгоритма лежит в этом конечном множестве).
    \item $\{ q \in \Q : q < e \}$. Для начала заметим, что это вообще-то не подмножество натуральных чисел. Но опять же, между рациональными и натуральными есть биекция, так что ничего не ломается. Алгоритм основывается на следующем факте: \[ \left(1 + \frac{1}{n} \right)^n < e < \left(1 + \frac{1}{n} \right)^{n+1} \]
    Таким образом, при увеличении $n$ рано или поздно $q$ не будет лежать между этими числами и мы c легкостью поймем, с какой стороны от $e$ оно лежит.
    \item $\{ n \, | \text{ в числе $\pi$ есть $n$ девяток подряд} \}$. Докажем неконструктивно. Это множество либо совпадает со всем $\mathcal{N}$, либо оно конечно. В обоих случаях получается разрешимое множество.
\end{enumerate}

\begin{conj}
    $S \subseteq \mathcal{N}$ называется полуразрешимым, если существует такой алгоритм $\mathcal{A}$, который мы будем называть полуразрешающим, такой, что \begin{itemize}
        \item если $x \in S$, то $\mathcal{A}(x) = 1$
        \item если $x \notin S$, то $\mathcal{A}$ не остановится.
    \end{itemize}
\end{conj}

Очевидно, что если $S$ разрешимо, то они и полуразрешимо, так как вместо ответа 0 мы просто уйдем в бесконечный цикл.

\begin{conj}
    $S \subseteq \mathcal{N}$ называется перечислимым, если существует такой алгоритм $\mathcal{A}$, который мы будем называть перечисляющим, такой, что на пустом входе он работает бесконечно долго и через запятую перчисляет все элементы множества $S$ и только их (в случае если $S$ конечно, он перечислит их всех и зависнет). 
\end{conj}
\begin{notice}
    Можно считать, что элементы выводятся без повторений.
\end{notice}

\begin{theorem}
    $S \subseteq \mathcal{N}$ полуразрешимо $\Longleftrightarrow S$ перечислимо. 
\end{theorem}
\begin{proof}
    \quad 

    \quad $\quad"\Leftarrow":$ Запустим алгоритм ``ждуна'': будем перечислять элементы и ждать, не появится ли интересующий нас элемент. Если он есть в $S$, то рано или поздно появится, и мы выведем 1, иначе алгоритм так и не завершится, что тоже корректно.
    
    $\quad\quad "\Rightarrow":$ Будем пользоваться тем, что алгоритм можно выполнять по шагам. Построим следующую таблицу:
    \begin{center}
        \begin{tabular}{|c|| c | c | c| c | c | c | c |} 
         \hline
        4 &  &  & * & & \\ 
         \hline
        3 & * &  & & &  \\
         \hline
         2 &  &  & & &  \\
         \hline
         1 &  &  & & * &  \\
         \hline
         0 &  &  & & &  \\
         \hline\hline
          & 0  & 1  & 2 & 3 & 4 \\
         \hline
        \end{tabular}
    \end{center}
    \quad Снизу у нас пронумерованы входы, слева -- шаги. В клетке стоит звездочка, если алгоритм на соотвествующем входе завершается ровно на этом шаге. В каждой колонке может быть либо не более одной звездочки. 
    
    \quad Наша задача -- перечислить те входы, у которых есть звездочка. Давайте обходить таблицу по диагонали и для каждой клетки проверять, есть ли там звездочка. Если есть, то выведем номер входа. Очевидно, что это будет работать.
\end{proof}

\textbf{Теорема Поста.} Если $S$ и $\mathcal{N} \setminus S$ перечислимы, то $S$ -- разрешимо.

\begin{proof}
    Воспользуемся предыдущей теоремой: пусть $\mathcal{A}_1$ -- полуразрешающий алгоритм для $S$, $\mathcal{A}_2$ -- полуразрешающий алгоритм для $\mathcal{N} \setminus S$. Запустим их параллельно (например, будем выолнять шаги алгоритмов по очереди). Один из них точно остановится. Если первый, то мы вернем 1, если второй то 0.
\end{proof}

\begin{theorem}
    \begin{gather*} S \subseteq \mathcal{N} \text{ перечислимо } \Longleftrightarrow \\
        \Longleftrightarrow \exists  \text{ разрешимое множество пар } \mathcal{B} \subseteq \mathcal{N} \times \mathcal{N} : S = \{ x \in \mathcal{N} \, | \; \exists y : (x, y) \in \mathcal{B} \} \end{gather*}
    Тут $y$ иногда называют доказательством того, что $x \in S$.
\end{theorem}
\begin{proof}
    \quad 

    \quad $\quad"\Leftarrow":$ Построим полуразрешающий алгоритм для $S$. Будем перебирать $y$ и запускать разрешающий алгоритм для $(x, y)$. Если $(x, y) \in \mathcal{B}$, то выдаем 1. Если такой $y$ не найдется, то мы и не остановимся.

    $\quad\quad "\Rightarrow":$ Пусть $\mathcal{A}$ -- полуразрешающий алгоритм для $S$. Построим $\mathcal{B}$ следующим образом: \[ \mathcal{B} = \{ (x, t) \, | \; \mathcal{A}(x) \text{ остановится за $t$ шагов}  \} \]
    \quad Почему это множество разрешимо? Для произвольной пары $(x, y)$ мы хотим проверить принадлежит ли она $\mathcal{B}$. Давайте запустим алгоритм $\mathcal{A}$ на $x$ и отсчитаем $y$ шагов. Если он остновится, то возвращаем 1, иначе 0. Ну и нетрудно видеть, что проекция $\mathcal{B}$ на первый элемент пар это ровно $S$, потому что если $x \in S$, то по определению найдется $t$, что $\mathcal{A}(x)$ остановится за $t$ шагов.
 
\end{proof}

Введем понятие вычислимости для функций. 
\begin{conj}
    Пусть $M \subseteq \mathcal{N}$. Функция f задана следующим образом:
    \begin{gather*}
        f : M \longrightarrow \mathcal{N}
    \end{gather*}
    f называется вычислимой $\Longleftrightarrow \exists$ алгоритм $\mathcal{A}$:
    \begin{enumerate}
        \item $\forall x \in M \qquad \mathcal{A}(x) = f(x)$
        \item $\forall x \notin M \qquad \mathcal{A}(x)$ не останавливается
    \end{enumerate}
\end{conj}

\begin{lemma}
    Множество $S$ -- перечислимо $\Longleftrightarrow S$ -- это область определения вычислимой функции. 
\end{lemma}
\begin{proof}
    \quad 

    \quad $\quad"\Rightarrow":$ Строим полуразрешающий алгоритм. Он и будет задавать эту функцию $f$.

    $\quad\quad "\Leftarrow":$ Полуразрешающий алгоритм для $S$: запустить алгоритм для функции и заменить его ответ на 1, если он остановился и дал ответ.

\end{proof}

\begin{lemma}
    Множество $S$ -- перечислимо $\Longleftrightarrow S$ -- это область значений вычислимой функции. 
\end{lemma}
\begin{proof}
    \quad 

    \quad $\quad"\Rightarrow":$ Строим полуразрешающий алгоритм $\mathcal{A}$ для $S$. Если $\mathcal{A}(x)$ останавливается и выдает 1, то заменить его ответ на $x$.

    $\quad\quad "\Leftarrow":$ Так как функция вычислима, область ее определения перечислима. Построим перечисляющий алгоритм для области значений следующим образом: Запустим перечисляющий алгоритм. Если он напечатал $x$, то напечатаем $f(x)$. 

\end{proof}

\begin{conj}
    Графиком функции $f : M \longrightarrow \mathcal{N}$ будем называть множество:
    \begin{gather*}
        \Gamma_f = \{(x, f(x)) \mid x \in M\}
    \end{gather*}
\end{conj}
\begin{theorem}
    Функция $f : M \longrightarrow \mathcal{N}$ вычислима $\Longleftrightarrow$ график $f$ перечислим. 
\end{theorem}
\begin{proof}
    \quad 

    \quad $\quad"\Rightarrow":$ Так как $f$ вычислима, то $M$ перечислимо. Тогда перечисляем $M$ и когда получили $x$, то напечатаем пару $(x, f(x))$. $f(x)$ мы точно когда нибудь досчитаем, так как мы перечисляем область определения $f$. 

    $\quad\quad "\Leftarrow":$ Построим алгоритм для вычисления $f$: на вход подается $x$. Мы запускаем перечислияющий алгоритм для графика $f$. Если будет напечатана пара $(x, y)$, выдаем $y$. Это будет значить, что $x$ лежал в $M$. Иначе зависаем. 

\end{proof}

Ответим на пару животрепещущих вопросов:
\begin{itemize}
    \item Существуют ли неразрешимые множества? 
    
    \textit{Да, так как для каждого разрешимого множества должен существовать алгоритм. Алгоритмов счетное число, подмножеств натуральных чисел несчетное. Таким образом, получаем, что обязаны существовать неразрешимые множества.}
    \item Существуют ли неперечислимые множества? 
    
    \textit{Аналогично предыдущему из соображений мощности.}
    \item Существует ли неразрешимое, но перечислимое множество? 
    
    \textit{Да, давайте это докажем.}
    \begin{proof}
        Вспомним, что алгоритму соотвествует текст, а тексту можно поставить в соответствие число из $\mathcal{N}$. Обратное соответствие тоже есть. Тем натуральным числам, для которых текст не является корректным алгоритмом, в соответствие поставим тривиальный алгоритм(Алгоритм ничего не делает и сразу останавливается). Таким образом имеем биекцию между натуральными числами и алгоритмами. 
        
        Введем обозначение: 
        Пусть $\# \mathcal{A}$ -- номер алгоритма $\mathcal{A}$. А $\langle n \rangle$ -- алгоритм с номером $n$. 
        
        Введем также так называемый универсальный алгоритм $U(n, x) = \langle n \rangle (x)$. И еще на первый взгляд бесполезную конструкцию: $u(n) := U(n, n) = \langle n \rangle (n)$. Заметим, что:
        \begin{itemize}
            \item Очевидно, что функция $u(n)$ вычислима, так как есть алгоритм, который ее вычисляет.
            \item $u(n)$ определена не везде.
        \end{itemize} 
        \begin{lemma}
            Функцию $u(n)$ нельзя доопределить до всюду определенной вычислимой функции. 
        \end{lemma}
        \begin{proof}
            От противного. Пусть $u'$ -- продолжение $u$ и является вычислимой. $u' : \mathcal{N} \longrightarrow \mathcal{N}$. $\forall n$, если $u(n)$ останавливается, то $u(n) = u'(n)$. Хотим прийти к противоречию и сказать, что такая функция $u'$ не может существовать. 

            Для этого введем $d(n) = u'(n) + 1$ -- всюду определенная вычислимая функция. Раз $d$ -- всюду определенная вычислимая, то она вычисляется каким тьо алгоритмом. Возьмем номер этого алгоритма и запустим функцию $u$ на этом номере. Тогда по определению:
            \begin{gather*}
                u(\# d) = \langle \# d \rangle (\# d)= d (\# d) = \oast
            \end{gather*}. А также, по определению функции $u'$:
            \begin{gather*}
                \oast = u'(\# d) + 1
            \end{gather*}
            Таким образом получаем, что $u(\# d) = u'(\# d) + 1$, а значит $u'$ не является продолжением $u$, а значит мы получили противоречие.
        \end{proof}
        \follow \; Посмотрим на область определения $u$. Пусть $u : W \longrightarrow \mathcal{N}$, где $w$:
        \begin{gather*}
            W = \{n \mid \langle n \rangle (n) \text{ -- останавливается.} \}
        \end{gather*} 
        $W$ -- перечислимо, так как является областью определения вычислимой функции. Утверждается, что $W$ не является разрешимым.
        \begin{proof}
            От противного. Пусть $W$ разрешимо. Тогда мы могли бы рассмотреть такую функцию $u'(n)$:
            \begin{itemize}
                \item Если $n \in W$, то выдать $u(n)$, иначе выдать 0
            \end{itemize} 
            Понятно, что такая функция $u'(n)$ будет вычислимым и всюдуопределенным продолжением $u$. А это противоречие с Леммой. 
        \end{proof}
        Итого, наше построенное множество $W$:
        \begin{gather*}
            W = \{n \mid \langle n \rangle (n) \text{ останавливается}\}
        \end{gather*} 
        является перечислимым, но не является разрешимым. Победа.
    \end{proof} 
    \notice \; Теперь мы можем построить явный пример неперечислимого множества:
    \begin{gather*}
        \overline W = \{n \mid \langle n \rangle (n) \text{ не останавливается}\}
    \end{gather*}
    Оно неперечеслимо, так как иначе и $W$ и $\overline W$ были бы перечислимы, а тогда по теореме Поста $W$ было бы разрешимо. 
\end{itemize}

Итак, мы построили первые примеры всевозможных множеств, обладающих загадочными свойствами. Чтобы упростить себе жизнь для будущих доказательств, научимся доказывать факты о множествах, введя понятие сведения. 
\begin{conj}
    Пусть есть два множества $A$ и $B$. Будем говорить, что $A \leqslant_m B$ (``$m$ сводится''), если $\exists$ такая всюдуопределенная вычислимая функция $f$:
    \begin{gather*}
        \forall x, \quad x \in A \Longleftrightarrow f(x) \in B
    \end{gather*} 
    Над буквой $m$ в обозначении лучше особо не задумываться. $m$ от слова mapping.  
\end{conj}

\underline{Свойства сведений}:
\begin{enumerate}
    \item Транзитивность \qquad $A \leqslant_m B, B \leqslant_m C \Longrightarrow A \leqslant_m C$
    \item $A \leqslant_m B, \; B$ -- разрешимо $\Longrightarrow A$ -- разрешимо. 
    
    $A \leqslant_m B, \; B$ -- перечислимо $\Longrightarrow A$ -- перечислимо.  

    Проверяется это очень просто. Если $B$ разрешимо,то разрешающий алгоритм для $A$ -- это посчитать $f(x)$ и узнать, пренадлежит ли оно $B$. 

    Для перечислимых и полуразрешимых аналогично.
\end{enumerate}

\textit{\textbf{Примеры:}}

\begin{enumerate}
    \item Пусть $H$ -- это Halting problem, то есть:
    \begin{gather*}
        H = \{ (n, x) \mid \langle n \rangle (x) \text{ останавливается} \}
    \end{gather*}
    Построим сведение $W \leqslant_m H$. Любому $n$ просто будем сопоставлять пару $(n, n)$. 
    \item Пусть:
    \begin{gather*}
        H_0 = \{ n \mid \langle n \rangle (0) \text{ останавливается} \}
    \end{gather*}
    Сведем $W$ к $H_0$. По $n$ будем выдавать номер следующего алгоритма: ``Проигнорируй входные данные и запусти $\langle n \rangle (n)$.''
\end{enumerate}