\section{Вычислимость}
\subsection{Введение}
В данном параграфе $\Sigma$ -- это конечный алфавит, а $\Sigma^*$ - множество строк в нем.

Пока что не будем давать точное определение понятия алгоритм, а просто выпишем его главные характеристики: 
\begin{itemize}
    \item Алгоритм получает на вход строку и либо завершается и выдает какую-то строку, либо не останавливается.
    \item Алгоритм можно записать.
    \item Алгоритм можно исполнять по шагам.
\end{itemize}
Введем еще одно обозначение: $\mathcal{N} := \{0, 1, 2, \dots \}$ -- натуральные числа с 0. Обычные натуральные числа без 0 все так же будем обозначать $\N$.

\begin{conj}
    $S \subseteq \mathcal{N}$ называется разрешимым, если существует такой алгоритм $\mathcal{A}$, что \begin{itemize}
        \item $\forall x \in S \quad \mathcal{A}(x) = 1$
        \item $\forall x \notin S \quad \mathcal{A}(x) = 0.$
    \end{itemize}
\end{conj}
Заметим, что в свойствах алгоритма мы говорили про то, что на вход ему подаются строки, а тут -- натуральные числа. Но это законно, потому что мы можем отождествить натуральные числа со строками: сначала идет пустая строка, потом все строки длины 1 (их конечное число), потом все строки длины 2 (их конечное число) и т.д.

\textbf{Примеры разрешимых множеств:} \begin{enumerate}
    \item Само $\mathcal{N}$ разрешимо (всегда выдаем 1) и $\varnothing$ разрешимо (всегда выдаем 0).
    \item Множество четных чисел (просто проверяем на четность)
    \item Множество простых чисел (можем честно проверить на простоту, времы выполнения нас не волнует)
    \item Любое конечное множество (просто проверяем, что вход алгоритма лежит в этом конечном множестве).
    \item $\{ q \in \Q : q < e \}$. Для начала заметим, что это вообще-то не подмножество натуральных чисел. Но опять же, между рациональными и натуральными есть биекция, так что ничего не ломается. Алгоритм основывается на следующем факте: \[ \left(1 + \frac{1}{n} \right)^n < e < \left(1 + \frac{1}{n} \right)^{n+1} \]
    Таким образом, при увеличении $n$ рано или поздно $q$ не будет лежать между этими числами и мы c легкостью поймем, с какой стороны от $e$ оно лежит.
    \item $\{ n \, | \text{ в числе $\pi$ есть $n$ девяток подряд} \}$. Докажем неконструктивно. Это множество либо совпадает со всем $\mathcal{N}$, либо оно конечно. В обоих случаях получается разрешимое множество.
\end{enumerate}

\begin{conj}
    $S \subseteq \mathcal{N}$ называется полуразрешимым, если существует такой алгоритм $\mathcal{A}$, который мы будем называть полуразрешающим, такой, что \begin{itemize}
        \item если $x \in S$, то $\mathcal{A}(x) = 1$
        \item если $x \notin S$, то $\mathcal{A}$ не остановится.
    \end{itemize}
\end{conj}

Очевидно, что если $S$ разрешимо, то они и полуразрешимо, так как вместо ответа 0 мы просто уйдем в бесконечный цикл.

\begin{conj}
    $S \subseteq \mathcal{N}$ называется перечислимым, если существует такой алгоритм $\mathcal{A}$, который мы будем называть перечисляющим, такой, что на пустом входе он работает бесконечно долго и через запятую перчисляет все элементы множества $S$ и только их (в случае если $S$ конечно, он перечислит их всех и зависнет). 
\end{conj}
\begin{notice}
    Можно считать, что элементы выводятся без повторений.
\end{notice}

\begin{theorem}
    $S \subseteq \mathcal{N}$ полуразрешимо $\Longleftrightarrow S$ перечислимо. 
\end{theorem}
\begin{proof}
    \quad 

    \quad $\quad"\Leftarrow":$ Запустим алгоритм "ждуна": будем перечислять элементы и ждать, не появится ли интересующий нас элемент. Если он есть в $S$, то рано или позно появится, и мы выведем 1, иначе алгоритм так и не завершится, что тоже корректно.
    
    $\quad\quad "\Rightarrow":$ Будем пользоваться тем, что алгоритм можно выполнять по шагам. Построим следующую таблицу:
    \begin{center}
        \begin{tabular}{|c|| c | c | c| c | c | c | c |} 
         \hline
        4 &  &  & * & & \\ 
         \hline
        3 & * &  & & &  \\
         \hline
         2 &  &  & & &  \\
         \hline
         1 &  &  & & * &  \\
         \hline
         0 &  &  & & &  \\
         \hline\hline
          & 0  & 1  & 2 & 3 & 4 \\
         \hline
        \end{tabular}
    \end{center}
    \quad Снизу у нас пронумерованы входы, слева -- шаги. В клетке стоит звездочка, если алгоритм на соотвествующем входе завершается ровно на этом шаге. В каждой колонке может быть либо не более одной звездочки. 
    
    \quad Наша задача -- перечислить те входы, у которых есть звездочка. Давайте обходить таблицу по диагонали и для каждой клетки проверять, есть ли там звездочка. Если есть, то выведем номер входа. Очевидно, что это будет работать.
\end{proof}

\textbf{Теорема Поста.} Если $S$ и $\mathcal{N} \setminus S$ перечислимы, то $S$ -- разрешимо.

\begin{proof}
    Воспользуемся предыдущей теоремой: пусть $\mathcal{A}_1$ -- полуразрешающий алгоритм для $S$, $\mathcal{A}_2$ -- полуразрешающий алгоритм для $\mathcal{N} \setminus S$. Запустим их параллельно (например, будем выолнять шаги алгоритмов по очереди). Один из них точно остановится. Если первый, то мы вернем 1, если второй то 0.
\end{proof}

\begin{theorem}
    \begin{gather*} S \subseteq \mathcal{N} \text{ перечислимо } \Longleftrightarrow \\
        \Longleftrightarrow \exists  \text{ разрешимое множество пар } \mathcal{B} \subseteq \mathcal{N} \times \mathcal{N} : S = \{ x \in \mathcal{N} \, | \; \exists y : (x, y) \in \mathcal{B} \} \end{gather*}
    Тут $y$ иногда называют доказательством того, что $x \in S$.
\end{theorem}
\begin{proof}
    \quad 

    \quad $\quad"\Leftarrow":$ Построим полуразрешающий алгоритм для $S$. Будем перебирать $y$ и запускать разрешающий алгоритм для $(x, y)$. Если $(x, y) \in \mathcal{B}$, то выдаем 1. Если такой $y$ не найдется, то мы и не остановимся.

    $\quad\quad "\Rightarrow":$ Пусть $\mathcal{A}$ -- полуразрешающий алгоритм для $S$. Построим $\mathcal{B}$ следующим образом: \[ \mathcal{B} = \{ (x, t) \, | \; \mathcal{A}(x) \text{ остановится за $t$ шагов}  \} \]
    \quad Почему это множество разрешимо? Для произвольной пары $(x, y)$ мы хотим проверить принадлежит ли она $\mathcal{B}$. Давайте запустим алгоритм $\mathcal{A}$ на $x$ и отсчитаем $y$ шагов. Если он остновится, то возвращаем 1, иначе 0. Ну и нетрудно видеть, что проекция $\mathcal{B}$ на первый элемент пар это ровно $S$, потому что если $x \in S$, то по определению найдется $t$, что $\mathcal{A}(x)$ остановится за $t$ шагов.
 
\end{proof}
