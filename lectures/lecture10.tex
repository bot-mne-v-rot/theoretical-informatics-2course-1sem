\vspace{5mm}

\subsection{Алгоритм. Машина Тьюринга}

Теперь введем формальное понятие алгоритма. А точнее сразу 2: \begin{itemize}
    \item \textbf{Алгоритм} -- программа с конечным количеством переменных.
    \item \textbf{Алгоритм} -- машина Тьюринга.
\end{itemize}
Разберемся сначала с первым: \begin{itemize}
    \item Переменные: $a_1, a_2, \dots, a_k \in \mathcal{N}$.
    \item Строки нумеруются в возрастающем порядке.
    \item Есть команды инкрементирования / декрементирования: a++, a- - (в последнем случае для 0 выдаст ошибку).
    \item Есть оператор goto.
    \item Есть условный оператор.
    \item Есть команда stop.
\end{itemize}
Приведем несколько примеров: \begin{enumerate}
    \item z := 0 \begin{lstlisting}[language=c++]
        1. if (z > 0) goto 2 else goto 4
        2. z--
        3. goto 1
        4. ...
    \end{lstlisting}
    \item a := b \begin{lstlisting}[language=c++]
        1. a := 0
        2. c := 0
        3. if (b > 0) goto 4 else goto 8
        4. b--
        5. a++
        6. c++
        7. goto 3
        8. if (c > 0) goto 9 else goto 12
        9. b++
        10. c--
        11. goto 8
        12. ... 
    \end{lstlisting}
    \item a := b + c, a := b $\cdot$ c тоже легко расписывается.
    \item Также можно расписать: возведение в степень, деление с остатком, проверку на простоту, нахождение $n$-ого простого. Это все нужно нам для того, чтобы заводить массивы: \[ [a_1, a_2, \dots, a_n]  \Leftrightarrow p_1^{a_1 + 1} \cdot p_2^{a_2 + 1} \dots p_n^{a_n + 1}, \quad \text{где } p_i - \text{$i$-тое простое} \]
\end{enumerate}

\underline{Задача FRACTRAN (Джон Конвей)}

$r_1, r_2, \dots, r_k$ -- рациональные положительные числа, $m \in \mathbb{N}$.

На каждом шаге находим минимальное $i$, т.ч. $m \cdot r_i \in \mathbb{N}$, и делаем $m := m \cdot r_i$.

Задача состоит в том, чтобы по данным числам понять, остановится ли процесс. Определим множество: \[ FRACTRAN = \{ (r_1, \dots, r_m, k) \, | \text{ процесс остановится} \} \]

\begin{theorem}
    FRACTRAN -- неразрешимое множество.
\end{theorem}
\begin{proof}
    Построим сведение: $H \leqslant_m FRACTRAN$, где $H$ -- задача останова программы с конечным числом переменных (знаем, что это множество неразрешимо). То есть наша цель: \[ \text{программа с конечным числом переменных} \mapsto r_1, \dots, r_k, m \]
    Будем считать, что у нас всего 3 переменные: $a, b, c$ (для большего количества обобщается очевидным образом). Заметим, что число $2^a3^b5^c$ однозначным образом кодирует состояние перменных. Также нам важно знать номер текущей строки, для этого пронумеруем их простыми числами, большими номеров переменных, т.е. 7, 11, 13 и т.д. Итого, будем хранить  $2^a3^b5^cp$, где $p$ -- номер строки. 

    Каждой команде из нашей программы будем сопоставлять число в задаче $FRACTRAN$. Команд у нас не так и много: \begin{itemize}
        \item Инкрементирование. Разберем на примере: \begin{lstlisting}
            7. a++
            11. ...
        \end{lstlisting}
        Тогда добавим в задачу $FRACTRAN$ число $\frac{2 \cdot 11}{7}$. Домножили на 2, так как увеличили а на единицу, и на $\frac{11}{7}$, так как поменяли строку.

        Таким образом, если у нас была конфигурация $2^a3^b5^c \cdot 7$, она превратится в $2^{a+1}3^b5^c \cdot 11$.
        \item Декрементировоние. То же самое, только 2 идет в знаменатель.
        \item goto. Разберем на примере: \begin{lstlisting}
            7. goto 13
        \end{lstlisting}
        Это легко, ведь надо просто добавить число $\frac{13}{7}$.
        \item stop. Разберем на примере: \begin{lstlisting}
            23. stop
        \end{lstlisting}
        Это легко, ведь надо просто добавить число $\frac{1}{23}$.
        \item Условный оператор. Разберем на примере: \begin{lstlisting}[language=c++]
            7. if (a > 0) goto 13 else goto 17
        \end{lstlisting}
        Попробуем вычесть из $a$ единицу. Если получилось, то добавим в задачу число $\frac{13}{2 \cdot 7}$, иначе добавим число $\frac{17}{7}$. Проблема тут в том, что $a$ уменьшается на единицу. Для того, чтобы исправить это, изменим нашу программу, добавив умножение на 2 в блок на 13-ой строке.
        \textit{Вообще написан какой-то кек, я так и не понял, как это должно работать.}
    \end{itemize}
    Конфигурация $2^a3^b5^c \cdot p$ как раз и будет отражать число $m$ после каждой команды. Когда мы дойдем до $stop$ мы разделим на $p$, и,следовательно, больше не сможем ни на что домножить, так как в любом случае надо будет делить на номер строки. 

    Если же программа не закончится, то мы будем вечно добавлять числа, на которые будем домножать $m$, следовательно и процесс в игре $FRACTRAN$ не остановится. 
\end{proof}

\vspace{5mm}

Перейдем к определению \textbf{Машины Тьюринга}.

Она представляет собой бесконечную в одну сторону ленту:
\begin{center}
    \begin{tabular}{|c|c|c|c|c|c|c|c|c|}
        \hline
        $\blacktriangle$ & в & х & о & д & \textvisiblespace & \textvisiblespace & \textvisiblespace & \dots \\
        \hline
    \end{tabular}\\
    $\uparrow$
\end{center}
$\Sigma$ -- входной алфавит,\\$\blacktriangle \notin \Sigma$ -- символ начала ленты,\\ \textvisiblespace$ \notin \Sigma$ -- пробел (свободная ячейка),\\$\uparrow$ -- положение головки (указатель на какую-то ячейку),\\
$\Sigma' \supset \Sigma$ -- алфавит, используемый машиной Тьюринга, \\
$Q$ -- конечное множество состояний, причем $q_0, q_f \in Q$, где $q_0$ -- начальное состояние, $q_f$ -- конечное,\\
$\delta: Q \times \Sigma' \to Q \times \Sigma' \times \{\leftarrow, \rightarrow \}$ -- функция перехода (по паре (состояние, символ) мы понимаем в какое состояние перейти, какой символ поставить на место предыдущего и в какую сторону сдвинуться).

Как только мы переходим в состояние $q_f$, машина завершает свою работы, и то, что написано на ленте и будет результатом работы. Но конечно возможна ситуация, когда мы никогда не достигнем состояния $q_f$. 

\begin{example}
    \begin{enumerate}
        \item Прибаление единицы к двоичному числу, записанному наоборот (младшие биты в начале ленты): 1101 $\mapsto$ 0011.
        
        Зададим функцию перехода следующим образом: \begin{gather*}
            (q_0, 0) \mapsto (q_f, 1, -) \\
            (q_0, 1) \mapsto (q_0, 1, \rightarrow) \\
            (q_0, \text{\textvisiblespace)} \mapsto (q_f, 1, -)
        \end{gather*}
        \item Просто прибаление единицы к двоичному числу (старшие биты в начале ленты): 1101 $\mapsto$ 1110.
        
        Зададим функцию перехода следующим образом: \begin{itemize}
            \item Для начала дойдем до самого младшего бита:
            \begin{gather*}
                (q_0, 0) \mapsto (q_0, 0, \rightarrow) \\
                (q_0, 1) \mapsto (q_0, 1, \rightarrow) \\
                (q_0, \text{\textvisiblespace}) \mapsto (q_1, \text{\textvisiblespace}, \leftarrow)
            \end{gather*}
            \item Прибавляем единицу как и в предыдущем пункте:
            \begin{gather*}
                (q_1, 0) \mapsto (q_f, 1, -) \\
                (q_1, 1) \mapsto (q_0, 1, \leftarrow) \\
                (q_1, \blacktriangle) \mapsto (q_2, \blacktriangle, \rightarrow)
            \end{gather*}
            \item Осталось обработать случай, когда число состояло из одних единиц (теперь мы переделали его в одни нули):
            \begin{gather*}
                (q_2, 0) \mapsto (q_3, 1, \rightarrow) \\
                (q_3, 0) \mapsto (q_3, 0, \rightarrow) \\
                (q_3, 1) \mapsto (q_3, 1, \rightarrow) \\
                (q_3, \text{\textvisiblespace}) \mapsto (q_f, 0, -)
            \end{gather*}
        \end{itemize}
    \end{enumerate}
\end{example}

\textbf{Тезис Чёерча-Тьюринга.} Алгоритм $\equiv$ Машина Тьюринга.

Тут не будет формального доказательства, так как нет единого понятия алгоритм.

\begin{theorem}
    Функция $f$ вычисляется с помощью программы с конечным числом переменных $\Longleftrightarrow f$ вычисляется на машине Тьюринга. 
\end{theorem}
\begin{proof} \quad

    $\quad "\Rightarrow":$ на ленте будем хранить текущее состояние переменных: \[ a_1 \# a_2 \# \dots \# a_n\]
    \quad Шаг за шагом будем менять их значения (это может быть долго и неприятно, так как надо будет что-то сдвигать, но на временной аспект нам все равно). В итоге, если программа вычисляет какое-то значение, это значение будет храниться на ленте.
    
    $\quad "\Leftarrow":$ как удобно хранить состояние ленты? Оказывается, что в виде двух стеков (от начала до головки и от конца до головки): 
    \begin{center}
        \begin{tabular}{|c|c|c|c|c|c|c|c|c|}
            \hline
            $-$ & $-$ & $-$ & $\rightarrow$ & c & $\leftarrow$ & $-$ & $-$ & $-$ \\
            \hline
        \end{tabular}\\
        $s_1 \quad\quad \uparrow \quad\quad s_2$ 
    \end{center}
    \quad Таким образом, мы будем хранить $(s_1, c, s_2)$. Как хранить стек? Например, в виде такого числа: \[ n = a_1 + k \cdot a_2 + k^2 \cdot a_3 + \dots \]
    \quad Теперь, чтобы взять верхний элемент, нужно сделать $n := n \mod k$. А чтобы добавить элемент $a$, надо сделать $n := n * k + a$.

    \quad Таким образом, по переходам машины Тьюринга мы будем менять состояние переменных в нашей программе. \textit{Очередное кекнутое доказательство, не надейтесь, что на лекции он что-то большее.}
\end{proof}

\begin{conj}
    Универсальная машина Тьюринга -- по паре $(M, x)$ моделирует поведение машины $M$ на входе $x$.
\end{conj}
В целом это довольно просто, надо лишь загрузить функцию перехода в начало ленты и при каждом шаге возращаться к ней и смотреть, куда идти дальше.

\vspace{5mm}

\subsection{Ассоциативные исчисления}

Приведем еще один пример неразрешимого множества. 

\textbf{Одностороннее ассоциативное исчисление.} У нас есть алфавит $\Sigma$ и конечное множество правил вида $x_i \to y_i$, где $x_i, y_i \in \Sigma$, которые означает, что подстроку $x_i$ можно заменить на $y_i$. Задача заключается в том, чтобы понять, можно ли получить из одного слова другое. 

\textbf{Двустороннее ассоциативное исчисление.} То же самое, только $x_i \leftrightarrow y_i$.

\begin{theorem}
    Выводимость в одностороннем ассоциативном исчислении алгоритмически неразрешима.
\end{theorem}
\begin{proof}
    Приведем сведение: $H \leqslant_m \{\text{ассоц. исч., в которых есть вывод}\}$ -- множества пар $x_i \to y_i$ с вопросами можно ли получить из $a$ $b$.

    Зафиксируем пару $(M, x)$, где $M$ это машина Тьюринга, а $x$ это ее вход. По этой паре построим соответствующее ассоциативное исчисление.

    Посмотрим на состояние ленты в кокретный момент времени. Все, что слева нашего символа назовем $\alpha$, все справа включенно -- $\beta$, текущее состояние это $q$: 
    \begin{center}
        \begin{tabular}{|c|c|c|c|c|c|c|c|c|}
            \hline
             & $\alpha$ &  &  & c &  &  & $\beta$ & \\
            \hline
        \end{tabular}\\
        $\uparrow q$
    \end{center}
    Будем кодировать наше состояние следующей строкой $[\alpha q \beta]$, где $q$ взято в другом алфавите, то есть мы можем его отличить. 
    Нам удобно кодировать состояние именно так, потому что при сдвиге головки, оно будет меняться буквально на пару символов.

    Теперь, в зависимости от того, куда сдвинется головка, определим правила ассоциативного исчисления. Слева представлены переходы головки, справа -- правила ассоциативного исчисления: \begin{gather*}
        \begin{aligned}
            (q, c) \mapsto (q', b, \rightarrow) \quad \crel{\Longrightarrow} \quad qc \to bq' \\ 
            (q, c) \mapsto (q', b, -) \quad \crel{\Longrightarrow} \quad qc \to q'b \\
            (q, c) \mapsto (q', b, \leftarrow) \quad \crel{\Longrightarrow} \quad xqc \to q'xb \quad \forall x \in \Sigma \\
        \end{aligned}
    \end{gather*}
    Это были общие правила, легко убедиться, почему они работают. Теперь отдельно разберемся с правым концом ленты:
    \begin{gather*}
        \begin{aligned}
            (q, \text{\textvisiblespace}) \mapsto (q', b, \rightarrow) \quad \crel{\Longrightarrow} \quad q] \to bq'] \\
            (q, \text{\textvisiblespace}) \mapsto (q', b, -) \quad \crel{\Longrightarrow} \quad q] \to q'b] \\
            (q, \text{\textvisiblespace}) \mapsto (q', b, \leftarrow) \quad \crel{\Longrightarrow} \quad xq] \to q'xb] \quad \forall x \in \Sigma \\
        \end{aligned}
    \end{gather*}
    И финальным состоянием: \begin{gather*}
        \begin{aligned}
            q_f \crel{\to} * \\
            *x \crel{\to} * \quad \forall x \in \Sigma \\
            x* \crel{\to} * \quad \forall x \in \Sigma \\
        \end{aligned}
    \end{gather*}
    Теперь в зависмости от того, остановится ли машина Тьюринга на входе $x$, мы можем ответить на вопрос, можно ли получить из строки $[q_0x]$ строку $*$.
\end{proof}




