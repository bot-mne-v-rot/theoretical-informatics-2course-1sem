\subsection{Конечные автоматы. Продолжение}
Продолжим говорить о языки распознающиеся конечными автоматами или регулярные языки. Давайте обсудим, как доказать, что некий язык не является регулярным. 

Стандартный способ доказательства нерегулярности языка -- лемма о накачке. 

\begin{lemma}
    Лемма о накачке(Pumping lemma)

    Для любого регулярного языка $L$ существует натуральное число $p$, такое, что $\forall x \in L :$ если $\abs{x} \geqslant p$, тогда $\exists u, v, w \in \Sigma^*$, что выполняются следующие свойства:
    \begin{enumerate}
        \item $x = uvw$
        \item $\abs{v} \geqslant 1$
        \item $\abs{uv} \leqslant p$
        \item $\forall k_{\geqslant 0} \quad uv^k w \in L$
    \end{enumerate}
\end{lemma}
\begin{proof}
    Пусть $L$ распознается детерменированным конечным автоматом(ДКА) с $n$ состояниями. Возьмем $p := n + 1$. Для любой строки $x$, длина которой хотя бы $p$ будем считывать ее префиксы до $p$-ого. 
    \begin{align*}
        &x_1 \\
        &x_1 x_2 \\
        &x_1 x_2 x_3 \\
        &\dots \\
        &x_1 \dots x_p
    \end{align*}
    После прочтение неких двух префиксов автомат попадет в одинаковое состояние, так как $p$ на единицу больше чем количество состояний. 
    Пусть это случилось на строках $x_1 \dots x_k$ и $x_1 \dots x_l$, причем $l > k$. Тогда $u, v$ и $w$ мы можем задать следующим образом:
    \begin{align*}
        &u = x_1 \dots x_k \\
        &v = x_{k+1} \dots x_l \\
        &w = x_{l+1} \dots x_{\abs{x}}
    \end{align*}
    Проверим, что выполняются свойства леммы. Первое свойство очевидно, $x$ -- конкатенация трех строк. Второе свойство тоже выполняется, $\abs{v} \geqslant 1$, так как $l$ строго больше $k$. Третье свойство выполняется, $\abs{uv} \leqslant p$, так как $l \leqslant p$. Проверяем последнее свойство: обозначим состояние в которое мы попали, прочитав $u$ за $q$, тогда прочитав дальше $v$ мы тоже попадаем в состояние $q$, так как мы говорили, что при прочтении $k$-ого и $l$-ого префиксов мы попадаем в одно состояние. Далее прочитав $w$ мы точно попадем в конечное состояние. Таким образом, нам не важно, сколько раз читать строку $v$, ведь перед ее чтением мы всегда в состоянии $q$ и после ее прочтения мы тоже остаемся в состоянии $q$. То есть $\forall k_{\geqslant 0} \quad uv^k w \in L$, а значит четвертое свойство леммы тоже выполняется. 
\end{proof}

Разберем несколько примеров, как доказывается нерегулярность языков с помощью леммы о накачке. 

\textbf{Примеры:}
\begin{enumerate}
    \item Возьмем тот же язык, чью нерегулярность мы уже доказывали в прошлом параграфе. $L = \{ 0^n 1^n \mid n \in \{ 0, 1, \dots, \} \}$. Пусть $p$ -- число из леммы о накачке(по английски его обычно называют pumping length). Рассмотрим строку $0^{p+1} 1^{p+1}$. Она очевидно лежит в $L$. Заметим, что поскольку $\abs{uv} \leqslant p$, то $u$ и $v$ состоят из нулей. А тогда мы получаем противоречие с четвертым свойством леммы, так как повторяя строку $v$ мы можем сколь угодно увеличить количество нулей относительно количества единиц и тогда получившаяся строка не будет лежать в языке. 
    \item Рассмотрим очень похожий пример, где $L = \{ w \in \{0, 1\}^* \mid \text{ в $w$ одинаковое число 0 и 1}\}$. Рассуждения те же самые. Строка $0^{p+1} 1^{p+1} \in L$, $u$ и $v$ полностью состоят из нулей и снова противоречие с четвертым свойством леммы. 
    \item Теперь $L = \{ ww \mid w \in \{0, 1\}^* \}$. Опять же возьмем строку $0^p 1 0^p 1$, $u$ и $v$ снова чисто нули и у нас снова противоречие. 
    \item Унарный язык, но в котором количество единиц является точным квадратом. $L = \{ 1^{n^2} \mid n \geqslant 0 \}$. Лемма о накачке говорит, что строка $u v^k w$ лежит в языке, при этом длина этой строки -- арифметическая прогрессия с разностью $\abs{v}$. Легко видеть, что среди полных квадратов не может быть никакой арифметической прогрессии. 
    \item Рассмотрим $L = \{0^i 1^j \mid i > j\}$. Пусть снова $p$ -- pumping length. Возьмем строку $0^{p+1} 1^p \in L$. Тогда $uv$ -- снова строка из нулей. Длина $v$ хотя бы 1. То есть $v$ состоит хотя бы из одного нуля. Тогда если мы применяем лемму о накачке для $k = 0$, то есть для строки $uw$, в ней будет не более, чем $p$ нулей, при этом утверждается, что $uw \in L$. Но, заметив, что количество нулей в $uw$ не может быть больше количества единиц мы понимаем, что $uw$ не лежит в языке. Противоречие. 
\end{enumerate}

\notice \; Лемма о накачке является лишь необходимым условием регулярности языка, но не является достаточным. Существуют языки, не являющиеся регулярными, но для которых при этом выполняется условие леммы о накачке. Приведем замысловатый пример такого языка.

\textbf{Пример} \quad

Пусть $L$ задается так:
\begin{gather*}
    L = \{(ab)^n a^n \mid n \geqslant 1\} \cup \left( \{a, b\}^* \setminus (ab)^+ a^+ \right)
\end{gather*}
Под $x^+$ понимается $x x^*$. 
\begin{proof} \quad

    \begin{itemize}
        \item $L$ нерегулярный: 
        
        Язык $G = ((ab)^+ a^+)$ регулярный, так как задается регулярным выражением $ab(ab)^* a a^*$. Рассмотрим $L \cap g$:
        \begin{gather*}
            L \cap G = \{ (ab)^n a^n \mid n \geqslant 1 \}
        \end{gather*}
        $L \cap G$ нерегулярный по лемме о накачке $\Longrightarrow L$ нерегулярный, так как регулярные языки замкнуты относительно пересечения. 
        \item $L$ удовлетворяет лемме о накачке с $p = 3$:
        
        Че то там накачиваем и все сходится.
    \end{itemize}
\end{proof}

\subsection{Минимизация конечного автомата}

Пусть $\Sigma$ -- фиксированный алфавит. Для каждого языка $L \subseteq \Sigma^*$ определим бинарное отношение $\thicksim$. Пусть $x, y$ -- строки из $\Sigma^*$, будем говорить, что $x \thicksim y$, если:
\begin{gather*}
    \forall z \in \Sigma^* \quad xz \in L \Longleftrightarrow yz \in L
\end{gather*}
Проверим, что $\thicksim$ является отношением эквивалентности. 
\begin{proof} \quad

    \begin{enumerate}
        \item Рефлексивность: $x \thicksim x$ -- очевидно, так как языки замкнуты относительно инверсии строк. 
        \item Симметричности: $x \thicksim y \Longleftrightarrow y \thicksim x$ -- очевидно 
        \item Транзитивность: $x \thicksim y, y \thicksim z \Longrightarrow x \thicksim z$. Рассмотрим строку $t$. 
        \begin{gather*}
            xt \in L \Longleftarrow yt \in L \Longleftrightarrow zt \in L
        \end{gather*}
    \end{enumerate}
\end{proof}

Так как это отношение эквивалентности, $\Sigma^* / \thicksim$ -- множество классов эквивалентности. 

\begin{theorem}
    Язык $L$ -- регулярный тогда и только тогда, когда множество классов эквивалентности по отношению $\thicksim$ конечно.
\end{theorem}
\begin{proof} \quad

    \begin{enumerate}
        \item[``$\Longrightarrow$'':] Рассмотрим ДКА для языка $L$. Если две строки $x$ и $y$ читаются в одно состояние автомата, то $x \thicksim y$. Пусть $Q$ -- множество состояний автомата. Для любого $q \in Q$:
        \begin{gather*}
            S(q) := \{x : \text{ чтение $x$ заканчивается в $q$} \}
        \end{gather*}
        Мы уже поняли, что $\forall q$, все элементы $S(q)$ лежат в одном классе эквивалентности. При этом 
        \begin{gather*}
            \bigcup\limits_{q \in Q} S(q) = \Sigma^*
        \end{gather*}
        Очевидно, что класс эквивалентности представлен объединением какого-то количества $S(q)$. То есть классов эквивалентности точно не больше, чем количество состояний. То есть их конечное число.
        \item[``$\Longleftarrow$'':] Пусть наши классы эквивалентности по отношению $\thicksim$ -- это $X_1, X_2, \dots, X_n$. Построим на этих классах автомат. В автомате будет $n$ состояний $Q = \{0, 1, \dots, n\}$. Начальное состояние -- это $q_0$, такое, что пустая строка лежит в $q_0$. $\Sigma \in X_{q_0}$. Зададим правило перехода. При переходе из состояния $i$ по символу $a$ будем переходить в состояние $j$ следующим образом. 
        \begin{gather*}
            \delta(i, a) = j : \text{ для некоторой строки } s \in X_i \text{ строка } sa \in X_j
        \end{gather*}
        Хотим проверить корректность. Может ли быть такое, что: 
        \begin{gather*}
            \begin{cases}
                s_1 \in X_i \quad s_1 a \in X_i \\
                s_2 \in X_i \quad s_2 a \notin X_i
            \end{cases} \Longrightarrow \oast
        \end{gather*}
        Это будет значить, что $s_1 a$ и $s_2 a$ лежат в разных классах эквивалентности. 
        \begin{align*}
            \oast &\Longrightarrow s_1 a \cancel \thicksim s_2 a \\
            &\Longrightarrow \exists z : \begin{cases}
                s_1 a z \in L \\
                s_2 a z \notin L
            \end{cases} \\
            &\Longrightarrow s_1 \cancel \thicksim s_2
        \end{align*}
        Противоречие с тем, что $s_1$ и $s_2$ лежат в одном классе эквивалентности. То есть такого быть не может. То есть переход задан корректно и никакой неоднозначности нет.

        Чтобы доопределить автомат нам нужно сказать какое у нас множество финальных состояний. $F = \{ j \mid X_j \in L \}$. 

        Теперь индукцией по длине строки докажем, что строку $x$ автомат прочитает в состояние, которое соответствует классу эквивалентности $x$. База индукции: $x : \abs{x} = 0$. Тогда мы попадаем как раз в класс эквивалентности пустой строки. Переход $n-1 \to n$. Пусть $x_1 \dots x_{n-1}$ мы прочитали в состояние $j$, такое, что $x_1 \dots x_{n-1} \in X_j$. Мы так задавали переход, что $x_1 \dots x_{n-1} x_n$ будет лежать в $X_j$. Значит автомат прочитает строку в конечное состояние тогда и только тогда, когда она лежит в языке, а значит мы задали корректный конечный автомат.  
    \end{enumerate}
\end{proof}

\notice \; Этот автомат минимальный, так как теперь понятно, что состояний у автомата не может быть меньше, чем классов эквивалентности, а тут мы построили автомат в котором состояний ровно столько же сколько и классов. 

Теперь построим алгоритм, который позволяет строить минимальный ДКА. 

\hspace*{0.5cm}

\newcommand\mycommfont[1]{\footnotesize\ttfamily\textcolor{blue}{#1}}
\SetCommentSty{mycommfont}
\subsection*{Алгоритм Мура (1956г)}
На вход подается ДКА, состояния, алфавит, правила перехода : $(\Sigma, Q, q_0, \delta, F)$. Мы хотим разбивать множество состояний на условные классы. Пока не будем называть их именно классами эквивалентности. В каждый момент времени работы алгоритма $Q$ разбито на классы. 
\begin{gather*}
    Q = \bigsqcup\limits_{i = 1}^m R_i
\end{gather*} 
Первоначально $m = 1$. Ход работы алгоритма:
\begin{enumerate}
    \item Для начала удаляем все недостижимые из $q_0$ состояния. $m = 1$.
    \item Разбиваем на два класса -- финальные состояния и все остальные. Заметим, что две строки, одна из которых читается в конечное состояние, а другая -- не в конечное, не могут быть эквивалентны, так как элементы, которые читаются в финальное состояние, всегда можно дополнить пустой строкой. $m = 2$.
    \item Повторяем цикл, пока $m$ увеличивается 
    \begin{figure}[ht]
        \centering
        \begin{minipage}{.7\linewidth}
            \begin{algorithm}[H]
                \DontPrintSemicolon
                \SetAlgoLined
                \SetNoFillComment
                \While{$m$ увеличивается}{
                    \tcc{for loop №1}
                    \For{$a \in \Sigma$}{
                        \For{$q \in R$}{
                            Определим класс, в котором лежит $\delta(q, a)$\;
                            \If{Не все эти классы совпадают}{
                                $R = R_1' \sqcup \dots \sqcup R_k'$\;
                                Причем внутри $R_i'$ переходы по $a$ ведут все в один класс\;
                                Заменить $R$ на $R_1', \dots, R_k'$\;
                                \textbf{break} out of for loop №1\;
                            }
                        }
                    }
                }
            \end{algorithm}
        \end{minipage}
    \end{figure}
\end{enumerate}

Алгоритм работает до тех пор, пока $m$ увеличивается, $m$ не может стать больше чем $Q$, значит алгоритм точно останавливается.

Проверим теперь, что мы уже достаточно неплохо разбили наше множество состояний на классы. 

\textbf{Утверждение.} Если два состояния попали в разные классы, то они не эквивалентны. Состояния эквивалентны, если для любой строки, по которой из первого состояния мы приходим в финальное, то из второго по этой строке мы тоже придем в финальное состояние.
\begin{proof}
    Индукция по шагам алгоритма. База индукции : $R_1 = Q \setminus F, \; R_2 = F$. Почему выполняется условие индукции сказано в пункте (2). Переход: Пусть у нас $R$ было разбито как $R = R_1' \sqcup \dots \sqcup R_k'$. При этом:
    \begin{align*}
        \begin{cases}
            q_1 \in R_i' \\ 
            q_2 \in R_j' \\
            i \neq j 
        \end{cases} \Longrightarrow 
        &\begin{cases}
            \delta(q_1, a) \in R_l \\
            \delta(q_2, a) \in R_s \\
            l \neq s
        \end{cases} \overset{\text{ИП}}{\Longrightarrow} 
        \delta(q_1, a) \cancel \thicksim \delta(q_2, a) \\ 
        \Longrightarrow &\oast
    \end{align*}
    Обратно, то, что они не эквивалентны значит, что:
    \begin{align*}
        \oast \Longrightarrow &\exists z : \text{ из } \delta(q_1, a) \text{ мы приходим в финальное состояние по } z, \\ 
        &\text{ но из } \delta(q_2, a) \text{ не приходим в финальное состояние } \\
        \Longrightarrow &\text{строка } az \text{ разделяет } q_1 \text{ и } q_2 \text{ в различные классы} \\
        \Longrightarrow &\text{они лежат в разных классах }
    \end{align*}
\end{proof}

\textbf{Утверждение.} $R_1, \dots, R_m$ -- разбиение на классы в итоге работы алгоритма и выполняется условие:
\begin{gather*}
    \forall i \; \forall q_1, q_2 \in R_i \; \forall a \in \Sigma \quad \delta(q_1, a) \text{ и } \delta(q_2, a) \text{ попадают в один класс } R_j 
\end{gather*}
Значит мы можем рассмотреть автомат на множестве состояний $R_1, \dots, R_m$. Переход просто дает класс эквивалентности, начальное состояние -- класс, в котором лежит $q_0$. Множество финальных состояний -- классы, которые содержат состояния из $F$. 
Утверждение заключается в том, что построенный автомат принимает тот же самый язык $L$. 
\begin{proof}
    Рассмотрим строку $x$ из $L$. Пусть она принимается и последовательность состояний следующая: $q_{i_0} q_{i_1} \dots q_{i_k}$. Тогда в новом автомате при переходе к классам эквивалентности $[q_{i_0}] [q_{i_1}] \dots [q_{i_k}]$ корректность сохранится. Состояния останутся финальными. Новый атомат примет $x$.

    Если же $x \notin L$. Хотим доказать, что новый автомат тоже отвергнет $x$. Предположим это не так. Новый автомат принял $x$. Есть классы:
    \begin{gather*}
        R_{i_0} R_{i_1} \dots \tobelow{R_{i_k}}{\text{фин. класс}}
    \end{gather*}
    Заметим, что финальный класс содержит только состояния из исходного $F$, это видно из построения автомата. Тогда берем:
    \begin{align*}
        q_0 \in& R_{i_0} \\
        q_{i_1} \in& R_{i_1} \\
        \vdots& \\
        q_{i_k} \in& R_{i_k} \Longrightarrow q_{i_k} \in F \Longrightarrow \text{ противоречие}
    \end{align*} 
    Получили, что если новый автомат принял $x$, то и исходный принял бы $x$. То есть доказали утверждение, так как сказали, что $x \notin L$.
\end{proof}

\textbf{Утверждение.} Построенный автомат минимальный.
\begin{proof}
    Следует из того, что в минимальном автомате состояния -- это объединения некоторых состояний, а мы доказали, что в построенном нами автомате ничего объеденить нельзя.
\end{proof}

\begin{figure}[ht]
    \centering
    \begin{minipage}{.7\linewidth}
        \begin{algorithm}[H]
            \DontPrintSemicolon
            \SetAlgoLined
            \SetNoFillComment
            \While{$m$ увеличивается}{
                \tcc{два цикла вместе проходят $\abs{\Sigma} \cdot n$ операций}
                \For{$a \in \Sigma$}{
                    \For{$q \in R$}{
                        Определим класс, в котором лежит $\delta(q, a)$\;
                        \tcc{это происходит всего $\mathcal{O}(n)$ раз, т.к. у нас и так всего $n$ состояний}
                        \If{Не все эти классы совпадают}{
                            \tcc{при аккуратном хранении состояний и классов получаем $\mathcal{O}(n)$ на выполнение строк внутри $if$-а}
                            $R = R_1' \sqcup \dots \sqcup R_k'$\;
                            Причем внутри $R_i'$ переходы по $a$ ведут все в один класс\;
                            Заменить $R$ на $R_1', \dots, R_k'$\;
                            \textbf{break} out of for loop №1\;
                        }
                        \tcc{в совокупности $\mathcal{O}(n^2)$ на все деления}
                    }
                }
            }
        \end{algorithm}
    \end{minipage}
\end{figure}

Итоговая сложность алгоритма получается $\mathcal{O}(\abs{\Sigma} \cdot n^2)$
