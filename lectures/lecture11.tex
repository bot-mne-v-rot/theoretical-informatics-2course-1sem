\begin{theorem}
    Двустороннее ассоциативное исчисление тоже неразрешимо.
\end{theorem}
\begin{proof}
    Рассмотрим предыдущее построение и обратим все стрелочки. Проблема состоит в том, что одна и та же конфигурация могла получаться из разных конфигураций, следовательно, обратный шаг машины Тьюринга неодназначен. Однако, это не касается $*$, потому что $*$ могла получиться только из $q_f$, т.е. единственный способ получить $*$ -- прийти в $q_f$.

    Чтобы избавиться от неодназначности, докажем, что если существует вывод $*$, то существует вывод $*$ по прямым шагам машины. Для этого рассмотрим кратчайший вывод: пусть в нем исользовался обратный переход. Тогда после него должен был использоваться прямой, потому что иначе мы бы не пришли в $q_f$. Получается, что эту пару можно удалить из вывода, и ничего не поменяется. Противоречие с тем, что мы рассматривали кратчайший вывод.

    Таким образом, существует вывод $*$ по прямым правилам, а значит, задачу двустороннего исчисления эквивалентна одностороннему.
\end{proof}

\subsection{Теорема Успенского-Райса}
\begin{conj}
    Алгоритм $A$ эквивалентен алгоритму $B$, если \begin{enumerate}
        \item $\forall x \quad A(x)$ останавливается $\Leftrightarrow B(x)$ останавливается.
        \item $\forall x \quad A(x)$ останавливается $\Rightarrow A(x) = B(x)$.
    \end{enumerate}
    Обозначается, как $A \sim B$. Если вспомнить, что алгоритмы имеют номер, то также можно писать $\#A \equiv \#B$.
\end{conj}

\textit{Вообще говоря, это можно понимать так, что алгоритмы $A$ и $B$ задают одну и ту же вычислимую функцию.}

\begin{conj}
    $S \subset \mathcal{N}$ называется инвариантным, если \[ \forall a \in S, \; b \in \mathcal{N} \setminus S \quad a \not\equiv b \]
\end{conj}

\begin{theorem} (Успенского-Райса)
    Если инвариантное множество разрешимо, то либо $S = \varnothing$, либо $S = \mathcal{N}$.  
\end{theorem}
\begin{proof}
    От противного. Пусть $S$ инвариантно, а также $S \neq \varnothing$ и $S \neq \mathcal{N}$. Введем $L$ -- алгоритм, который нигде не останавливается. Не умаляя общности будем считать, то $\#L \in S$, так как понятие инвариантности симметрично.

    Возьмем $a \in \mathcal{N} \setminus S$, а также $W$ -- какое-то перечислимое, неразрешимое множество (например, то, что у нас было). Введем: \[ V(n, x) = \begin{cases}
        \langle a \rangle (x), \quad\quad\quad\quad\; \text{если } n \in W \\
        \text{не определно}, \quad \text{иначе}
    \end{cases} \]
    $V(n, x)$ -- вычислимая функция. Для начала полуразрешающим алгоритмом определяем, лежит ли $n$ в $W$. Если лежит, то запускаем $a$ на $x$ (причем $a$ может даже и не остановиться на $x$).

    На основе алгоритма, вычисляющего $V$, построим бесконечно много алгоритмов $V_n(x)$, где мы просто будем фиксировать $n$ в тексте алгоритма. Заметим, что если $n \in W$, то $V_n \sim \langle a \rangle$, иначе $V_n \sim L$.

    Построим сведение: \begin{gather*}
        W \leqslant_m \overline{S} \\
        n \xrightarrow{f} \#V_n
    \end{gather*}
    Если $n \in W$, то $\langle f(n) \rangle \sim \langle a \rangle$, а значит $f(n) \in \overline{S}$ (вспоминаем, что $a \in \overline{S}$).

    Если $n \notin W$, то $\langle f(n) \rangle \sim L$, а значит $f(n) \in S$ (вспоминаем, что $\#L \in S$). Значит, и правда есть сведение.

    Из неразрешимости $W$ получаем неразрешимость $\overline{S}$, а значит и неразрешимость $S$. Противоречие.
\end{proof}

\subsection{Теорема о неподвижной точке.}

\textit{Неформально: невозможно написать такой вирус (отображение из программ в программы), что он будет менять поведение любой программы.}

\begin{theorem} (Клини о неподвижной точке)
    Пусть $h$ -- всюду определенная вычислимая функция. Тогда найдется $m \in \mathcal{N} : m \equiv h(m)$.
\end{theorem}

Для доказательства теоремы сформулируем лемму. 

Ранее мы доказывали, что существует вычислимая функция, которую нельзя доопределить до всюду определенной вычислимой (мы еще обозначили ее $u$). Так вот продолжение по отношению эквивалентности всегда найдется. 

\begin{lemma}
    $f$ -- вычислимая функция, тогда существует всюду определенная вычислимая функция $g$, которая является продожением $f$ по отношению эквивалентности. Т.е. если $f$ определено, то алгоритмы с номерами $f(x)$ и $g(x)$ эквивалентны.
\end{lemma}

\begin{proof}
    Рассмотрим алгоритм $A(n, x)$:  \begin{lstlisting}[language=c++]
        k := f(n)
        return <k>(x)
    \end{lstlisting}
    Из него сделаем бесконечно много алгоритмов $A_n(x) := A(n, x)$. 
    Определим функцию $g$ как: \[ g(n) := \#A_n \]
    Очевидно, что $g$ будет всюду определенной вычислимой (нужно  просто брать номер соответсвующего алгоритма). Теперь если $f(n)$ определена, то $A_n \sim \langle f(n) \rangle$. А это и означает, что $g(n) \equiv f(n)$.
\end{proof}

Перейдем к доказательству теоремы Клини.

\begin{proof}
    Будем работать с той самой функцией $u(n) = \langle n \rangle (n)$. Пусть $b(n)$ -- это продолжение $u(n)$ по отношению эквивалентности. Введем \[ t(n) := h(b(n)) \]
    Так как $h$ и $b$ это всюду определенные вычислимые функции, $t$ тоже будет всюду определенной вычислимой. Поcчитаем $u(\#t)$: \[ u(\#t) \underbrace{=}_{\text{по опр. } u} t(\# t) \underbrace{=}_{\text{по опр. } t} h(b(\#t)) \]
    Вспомним, что $b$ -- продолжение $u$, следовательно $u(\#t) = b(\# t)$. Итого получили, что $b(\#t)$ -- неподвижная точка для $h$. 
\end{proof}

\begin{example}
    Существует алгоритм, который печатает свой номер. Это будет неподвижная точка для функции: \[ x \mapsto \#(\text{print } x) \]
\end{example}

\begin{example}
    Альтернативное доказательство теоремы Успенского-Райса. Опять же от противного: пусть $a \in S, b \in \mathcal{N} \setminus S$. Построим функцию: \[ h(x) := \begin{cases}
        a, \quad x \notin S \\
        b, \quad x \in S
    \end{cases} \]
    Если $S$ -- разрешимо, то $h$ -- всюду определенная вычислимая. Однако: \begin{gather*}
        \forall m : m \in S \quad h(m) = b \notin S \Rightarrow m \not\equiv h(m) \\
        \forall m : m \notin S \quad h(m) = a \in S \Rightarrow m \not\equiv h(m) \\
    \end{gather*}
    То есть получили, что у $h$ нет неподвижной точки. Противоречие.
\end{example}

\subsection{Главные нумерации вычислимых функций}
\begin{conj}
    $U(m, x)$ -- универсальная вычислимая функция, если \begin{enumerate}
        \item $U(m, x)$ -- вычислимая функция,
        \item $\forall$ вычислимой функции $f \;\exists m : \forall x \; f(x) = U(m, x)$.  
    \end{enumerate}
\end{conj}
\begin{conj}
    Универсальная вычислимая функция $U(n, x)$ -- главная нумерация, если для любой вычислимой функции $V(n, x)$ существует всюду определенная вычислимая функция $s$, т.ч. $V(n, x) = U(s(n), x) \; \forall n, x$.   
\end{conj}

\begin{example}
    $U(n, x) := \langle n \rangle (x)$ -- главная нумерация.

    Почему это универсальная вычислимая функция? Пусть $f$ -- вычислимая. Тогда $U(\#f, x) = f(x) \; \forall x$.

    Почему это главная нумерация? Пусть $V(n, x)$ -- вычислимая, а $s(n) = \#V_n$, где $V_n(x) := V(n, x)$. Тогда \[ U(s(n), x) = U(\#V_n, x) = V_n(x) = V(n, x) \] 
\end{example}

Сформулируем теорему о неподвижной точке в терминах главной нумерации. Пусть $U(n, x)$ -- главная нумерация, $h$ -- всюду определенная вычислимая функци. Тогда \[ \exists m : \forall x \quad U(h(m), x) = U(m, x) \]

\textbf{Утверждение.} Пусть $U, W$ -- главные нумерации. Если теорема о неподвижной точке выполняется для $W$, то она выполняется и для $U$. 
\begin{proof}
    Из определения главной нумерации существуют всюду определенные вычислимые функции $s$ и $g$, т.ч. \begin{gather*}
        W(n, x) = U(s(n), x) \\
        U(n, x) = W(g(n), x)
    \end{gather*}
    Пусть $h$ -- всюду определенная вычислимая, и мы хотим найти неподвижную точку в нумерации $U$.  Функция $g \circ h \circ s$ тоже всюду определенная вычислимая, тогда по теорме о неподвижной точке для $W$: \[ \exists m : \forall x \quad W(g(h(s(m))), x) = W(m, x) \]
    По свойству $s$: \[ W(m, x) = U(s(m), x) \]
    По свойству $g$: \[ W(g(h(s(m))), x) = U(h(s(m)), x) \]
    Итого $s(m)$ -- неподвижная точка $h$ для главной нумерации $U$.
\end{proof}

\subsection{Перечислимые предикаты и выразимость в арифметике}
\begin{conj}
    $P: \mathcal{N}^k \to \{ 0, 1 \}$ -- предикат
\end{conj}
\begin{conj}
    Предикат $P$ перечислимый $\Leftrightarrow$ множество $\{ \bar{x} \, | \; P(\bar{x}) = 1 \}$ перечислимо. Аналогично с разрешимостью (вообще мы часто будем отождествлять предикат с множеством значений, на котором он выдает 1).
\end{conj}
\begin{conj}
    Сигнатура $(\mathcal{N}, \times, +, 0, 1)$ -- арифметика.
\end{conj}
\begin{theorem}
    Любой перечислимый предикат выразим в арифметике. То есть его можно представить в виде формулы.
\end{theorem}
\begin{proof}
    Для удобства будем рассматривать предикат от одной переменной. Вспомним, что выражения вида: \[ \exists n \; \exists x_1, \dots, x_n : \dots \] мы умеем выражать с помощью $\beta$-функции Гёделя (выражением $\exists n \; \exists x_1, \dots, x_n : \dots$ мы заменяем на $\exists n, a, b$ и далее вместо $x_i$ используем $a \mod (bi + 1)$); 

    Пусть $A$ -- полуразрещающий алгоритм для $P$. В качестве алгоритма мы будем использовать программу с конечным числом переменных. Чтобы задать состояние программы нам понадобятся переменные, которыми она оперирует: $a_1, \dots, a_k$, и номер текущей строки $m$. Закодируем выражение ``$A$ останавливается на входе $x$'' как: \begin{gather*}
        \exists T, \\
        \exists a_1^{(1)}, \dots, a_1^{(T)}, \\
        \exists a_2^{(1)}, \dots, a_2^{(T)}, \\
        \dots \\
        \exists a_k^{(1)}, \dots, a_k^{(T)}, \\
        \exists m^{(1)}, \dots, m^{(T)} : \\
        (\text{усл. начала} \land \text{усл. конца} \land \text{усл. перехода})
    \end{gather*}
    Тут $T$ соответствует числу числу шагов программы. Осталось сформулировать условия.

    \underline{Условие начала}: \[ (a_1^{(1)} = x) \land (a_2^{(1)} = 0) \land \dots \land (a_k^{(1)} = 0) \land (m^{(1)} = s_1), \] где $s_1$ -- первая строка программы.
    
    \underline{Условие конца}: \[ m^{(T)} = s_{stop}, \] где $s_{stop}$ -- строка со $stop$.

    \underline{Условие перехода}: \[ \forall i \; (((i < T) \land (i \geqslant 1)) \Rightarrow step(a_1^{(i)}, a_2^{(i)}, \dots, a_k^{(i)}, m^{(i)}, a_1^{(i+1)}, a_2^{(i+1)}, \dots, a_k^{(i+1)}, m^{(i+1)})), \] где $step(a_1, a_2, \dots, a_k, m, a_1', a_2', \dots, a_k', m')$ -- это функция перехода. Чтобы ее описать, нужно написать большую дизъюнкцию следующего вида \[ ((m = s_1) \Rightarrow (\dots)) \land ((m = s_2) \Rightarrow (\dots)) \dots, \] где вместо $(\dots)$ мы описываем, как должны поменяться значения переменных, если мы выполняем инструкции на $s_i$-той строке.

    Например, пусть у нас есть следующие строки \begin{gather*}
        20. \; a_1 := a_3 \\
        30. \; \dots \dots \;
    \end{gather*}  
    Тогда в дизъюнкции ей будет соответсвовать следующий клоз: \[ (m = 20) \Rightarrow ((a_1' = a_3) \land (a_2' = a_2) \land \dots \land (a_k' = a_k) \land(m' = 30)) \]
    Построение формулы завершено.
\end{proof}

